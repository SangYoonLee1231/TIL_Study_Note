## 25.08.05 TIL

### JavaScript의 역사

- 1993년: 모자이크 웹 브라우저가 출시
  (Marc Andreesen과 Eric Bina가 개발한 최초의 그래픽 웹 브라우저)
- 1994년: Netscape, Netscape Navigator 출시
  당시 웹 브라우저는 돈을 지불하고 사용하는 유로 프로그램이었음
- 1994년.9월: 경쟁력을 높이기 위해 스크립트 언어 개발 시작
  (Brendan Eich가 개발한 최초의 스크립트 언어 - 10일만에 Mocha라는 이름으로 개발 완료)
  (-> LiveScript (인터프리터) 탑재)
- 1995년: 잘 알려지지 않자, 네임을 조금이라도 더 알리기 위해
  Java(Sun Microsystems)와 유사한 이름으로 JavaScript로 변경
- 1995년: 마이크로 소프트사의 Internet Explorer가 출시
  => Netscape Navigator을 Reverse Engineering하여 JScript 개발 및 출시 (양아치 행동)

<br/>

- 넷스케이프 vs 인터넷 익스플로러의 경쟁
- 1996년: Netscape와 Sun Microsystems가 JavaScript의 표준화를 위해
  ECMA International(웹 표준 단체)에 제안 (ECMA-262)
  -> 웹 브라우저에서 동작하는 언어에 대한 표준을 정립하자.
- 1997년: ECMAScript 1 표준 발표
- 1998년: ECMAScript 2 표준 발표
- 1999년: ECMAScript 3 표준 발표
  (정규 표현식, try/catch, switch 등 추가)
- 2000년: ECMAScript 4, 인터넷 익스플로러가 표준을 따라가지 않기로 선언
  -> 점유율 넷스케이프 10% 이내 (유료)
  -> 인터넷 익스플로러 90% 점유율 (무료, 윈도우 장사 + 인터넥 익스플로러 끼워팔기), 수익 모델이 있었음
  -> 컴퓨터, 윈도우(윈도우95, 윈도우98, me 등)와 함께 제공

<br/>

- 암흑기: 인터넷 익스플로러 폭군이 시장을 지배하던 시절

- 2004년 - Firefox 출시
- 다양한 웹 브라우저가 출시 -> 개발자에 대한 폭발적인 수요 -> 개발자가 많아짐
  -> 개발자 커뮤니티가 커짐 -> 플러그인이 개발 (Jquery, 2006)
- 2008년: 구글 크롬 출시
- 2009년: ECMAScript 5 표준 발표
  (strict mode, JSON, Array.forEach 등 추가)
- 2015년: ECMAScript 6 표준 발표
  (let, const, arrow function, class, module 등 추가)
  (_자바스크립트의 역사에서 가장 큰 변환점_)
- 2016년: ECMAScript 7 표준 발표
- 2017년: ECMAScript 8 표준 발표
  (async/await, Object.values, Object.entries 등 추가)
- 2018년: ECMAScript 9 표준 발표
- 2019년: ECMAScript 10 표준 발표
- 2020년: ECMAScript 11 표준 발표
  (optional chaining, nullish coalescing operator 등 추가)
- 2021년: ECMAScript 12 표준 발표
- 2022년: ECMAScript 13 표준 발표
- 2023년: ECMAScript 14 표준 발표
  (Array.prototype.at, Promise.any 등 추가)
  - ECMAScript 15 표준은 아직 발표되지 않았음
  - ECMAScript 15 표준은 2024년에 발표될 예정임

<br/>

---

### async와 defer의 차이

#### script태그의 async와 defer의 차이점을 아는 만큼 설명해보세요.

HTML 문서를 파싱하다가 만나는 \<script src="…"> 태그는 기본적으로 파일을 내려받고 곧바로 실행한 뒤에야 다시 파싱을 이어가기 때문에, 스크립트 크기가 크거나 네트워크가 느리면 그만큼 렌더링이 지연됩니다. 이 문제를 해결하기 위해 나온 두 가지 속성이 async와 defer입니다.

먼저 **async**를 지정하면 브라우저는 HTML 파싱과 병렬로 스크립트 파일을 다운로드하지만, **다운로드가 끝나는 즉시 실행**하기 때문에 실행 시점에 다시 파싱이 잠시 멈춥니다. 여러 async 스크립트가 있을 경우에는 다운로드 완료 순서에 따라 실행 순서가 달라지므로, 스크립트 간 의존성이 있을 때는 주의가 필요합니다.

반면 **defer**를 사용하면 역시 파싱과 병렬로 파일을 내려받지만, **실행은 문서 파싱이 완전히 끝난 뒤**, 즉 **DOM이 모두 준비된 시점이 되어야 비로소 시작**됩니다. 이 과정에서 스크립트들은 선언된 순서대로 차례차례 실행되므로, 순서 보장이 필수적인 라이브러리나 초기화 코드에 적합합니다.

요약하자면, async는 “다운로드 즉시 실행”으로 렌더링에 최소한의 지연을 주지만 실행 순서를 예측하기 어려운 반면, defer는 “파싱 완전 종료 후 순차 실행”으로 렌더링 블로킹을 피하면서도 순서와 DOM 준비를 보장해 주는 방식입니다.

<br/>

---

#### 왜 defer은 html 파싱을 끊지 않고 스크립트를 실행하나요?

defer 속성은 HTML5 명세에서 “다운로드와 실행을 분리”한다는 아이디어를 적용한 기능입니다.

일반적인 \<script> 태그는 만나자마자 파일을 내려받고 즉시 실행하기 때문에, 실행이 끝날 때까지 HTML 파싱이 멈추고 렌더링이 차단됩니다. 반면 defer를 사용하면 스크립트 파일은 파싱 도중에도 백그라운드에서 내려받기만 하고, 실제 실행은 “문서 파싱이 완전히 끝난 시점”까지 미룹니다. 이렇게 하면 HTML 구조가 먼저 빠르게 그려지고, 렌더 트리가 완성된 뒤에야 스크립트가 순서대로 실행되기 때문에 사용자에게는 페이지가 더 빨리 보이는 장점이 있습니다.

또한 스크립트가 DOM 준비를 전제로 작성된 경우, 파싱 완료 후에 실행되기 때문에 document.getElementById() 같은 메서드 호출 시점에 “요소를 찾을 수 없다”는 에러가 발생하지 않습니다. 즉, 렌더링 성능을 희생하지 않으면서도 스크립트 간 의존성(순서 보장)과 DOM 안정성을 모두 지킬 수 있는 것이죠. 브라우저 입장에서도 네트워크 다운로드와 HTML 파싱, 그리고 스크립트 실행을 병렬·순차적으로 조율할 수 있어 CPU와 I/O 자원을 효율적으로 쓸 수 있습니다.

정리하자면, defer는 “파싱 차단 없이 백그라운드에서 먼저 스크립트를 다운로드하고, 파싱이 끝난 뒤 순서대로 실행”하도록 설계된 속성입니다. 이를 통해 페이지 로딩 속도와 안정적인 초기화 과정을 동시에 만족시킬 수 있습니다.

<br/>

---

### 변수 - var(ES5), let, const(ES6)

- var의 단점

  - 변수 중복 선언이 가능하다. -> 변수값이 의도치않게 변경될 수 있다.  
    (let, const는 변수 중복 선언 시 에러 발생)

- let, const

  - let은 변수, 재할당 가능
  - const는 상수, 재할당 불가

<br/>
