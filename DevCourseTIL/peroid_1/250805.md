## 25.08.05 TIL

### JavaScript의 역사

- 1993년: 모자이크 웹 브라우저가 출시
  (Marc Andreesen과 Eric Bina가 개발한 최초의 그래픽 웹 브라우저)
- 1994년: Netscape, Netscape Navigator 출시
  당시 웹 브라우저는 돈을 지불하고 사용하는 유로 프로그램이었음
- 1994년.9월: 경쟁력을 높이기 위해 스크립트 언어 개발 시작
  (Brendan Eich가 개발한 최초의 스크립트 언어 - 10일만에 Mocha라는 이름으로 개발 완료)
  (-> LiveScript (인터프리터) 탑재)
- 1995년: 잘 알려지지 않자, 네임을 조금이라도 더 알리기 위해
  Java(Sun Microsystems)와 유사한 이름으로 JavaScript로 변경
- 1995년: 마이크로 소프트사의 Internet Explorer가 출시
  => Netscape Navigator을 Reverse Engineering하여 JScript 개발 및 출시 (양아치 행동)

<br/>

- 넷스케이프 vs 인터넷 익스플로러의 경쟁
- 1996년: Netscape와 Sun Microsystems가 JavaScript의 표준화를 위해
  ECMA International(웹 표준 단체)에 제안 (ECMA-262)
  -> 웹 브라우저에서 동작하는 언어에 대한 표준을 정립하자.
- 1997년: ECMAScript 1 표준 발표
- 1998년: ECMAScript 2 표준 발표
- 1999년: ECMAScript 3 표준 발표
  (정규 표현식, try/catch, switch 등 추가)
- 2000년: ECMAScript 4, 인터넷 익스플로러가 표준을 따라가지 않기로 선언
  -> 점유율 넷스케이프 10% 이내 (유료)
  -> 인터넷 익스플로러 90% 점유율 (무료, 윈도우 장사 + 인터넥 익스플로러 끼워팔기), 수익 모델이 있었음
  -> 컴퓨터, 윈도우(윈도우95, 윈도우98, me 등)와 함께 제공

<br/>

- 암흑기: 인터넷 익스플로러 폭군이 시장을 지배하던 시절

- 2004년 - Firefox 출시
- 다양한 웹 브라우저가 출시 -> 개발자에 대한 폭발적인 수요 -> 개발자가 많아짐
  -> 개발자 커뮤니티가 커짐 -> 플러그인이 개발 (Jquery, 2006)
- 2008년: 구글 크롬 출시
- 2009년: ECMAScript 5 표준 발표
  (strict mode, JSON, Array.forEach 등 추가)
- 2015년: ECMAScript 6 표준 발표
  (let, const, arrow function, class, module 등 추가)
  (_자바스크립트의 역사에서 가장 큰 변환점_)
- 2016년: ECMAScript 7 표준 발표
- 2017년: ECMAScript 8 표준 발표
  (async/await, Object.values, Object.entries 등 추가)
- 2018년: ECMAScript 9 표준 발표
- 2019년: ECMAScript 10 표준 발표
- 2020년: ECMAScript 11 표준 발표
  (optional chaining, nullish coalescing operator 등 추가)
- 2021년: ECMAScript 12 표준 발표
- 2022년: ECMAScript 13 표준 발표
- 2023년: ECMAScript 14 표준 발표
  (Array.prototype.at, Promise.any 등 추가)
  - ECMAScript 15 표준은 아직 발표되지 않았음
  - ECMAScript 15 표준은 2024년에 발표될 예정임

<br/>

---

### async와 defer의 차이

#### script태그의 async와 defer의 차이점을 아는 만큼 설명해보세요.

HTML 문서를 파싱하다가 만나는 \<script src="…"> 태그는 기본적으로 파일을 내려받고 곧바로 실행한 뒤에야 다시 파싱을 이어가기 때문에, 스크립트 크기가 크거나 네트워크가 느리면 그만큼 렌더링이 지연됩니다. 이 문제를 해결하기 위해 나온 두 가지 속성이 async와 defer입니다.

먼저 **async**를 지정하면 브라우저는 HTML 파싱과 병렬로 스크립트 파일을 다운로드하지만, **다운로드가 끝나는 즉시 실행**하기 때문에 실행 시점에 다시 파싱이 잠시 멈춥니다. 여러 async 스크립트가 있을 경우에는 다운로드 완료 순서에 따라 실행 순서가 달라지므로, 스크립트 간 의존성이 있을 때는 주의가 필요합니다.

반면 **defer**를 사용하면 역시 파싱과 병렬로 파일을 내려받지만, **실행은 문서 파싱이 완전히 끝난 뒤**, 즉 **DOM이 모두 준비된 시점이 되어야 비로소 시작**됩니다. 이 과정에서 스크립트들은 선언된 순서대로 차례차례 실행되므로, 순서 보장이 필수적인 라이브러리나 초기화 코드에 적합합니다.

요약하자면, async는 “다운로드 즉시 실행”으로 렌더링에 최소한의 지연을 주지만 실행 순서를 예측하기 어려운 반면, defer는 “파싱 완전 종료 후 순차 실행”으로 렌더링 블로킹을 피하면서도 순서와 DOM 준비를 보장해 주는 방식입니다.

<br/>

#### 왜 defer은 html 파싱을 끊지 않고 스크립트를 실행하나요?

defer 속성은 HTML5 명세에서 “다운로드와 실행을 분리”한다는 아이디어를 적용한 기능입니다.

일반적인 \<script> 태그는 만나자마자 파일을 내려받고 즉시 실행하기 때문에, 실행이 끝날 때까지 HTML 파싱이 멈추고 렌더링이 차단됩니다. 반면 defer를 사용하면 스크립트 파일은 파싱 도중에도 백그라운드에서 내려받기만 하고, 실제 실행은 “문서 파싱이 완전히 끝난 시점”까지 미룹니다. 이렇게 하면 HTML 구조가 먼저 빠르게 그려지고, 렌더 트리가 완성된 뒤에야 스크립트가 순서대로 실행되기 때문에 사용자에게는 페이지가 더 빨리 보이는 장점이 있습니다.

또한 스크립트가 DOM 준비를 전제로 작성된 경우, 파싱 완료 후에 실행되기 때문에 document.getElementById() 같은 메서드 호출 시점에 “요소를 찾을 수 없다”는 에러가 발생하지 않습니다. 즉, 렌더링 성능을 희생하지 않으면서도 스크립트 간 의존성(순서 보장)과 DOM 안정성을 모두 지킬 수 있는 것이죠. 브라우저 입장에서도 네트워크 다운로드와 HTML 파싱, 그리고 스크립트 실행을 병렬·순차적으로 조율할 수 있어 CPU와 I/O 자원을 효율적으로 쓸 수 있습니다.

정리하자면, defer는 “파싱 차단 없이 백그라운드에서 먼저 스크립트를 다운로드하고, 파싱이 끝난 뒤 순서대로 실행”하도록 설계된 속성입니다. 이를 통해 페이지 로딩 속도와 안정적인 초기화 과정을 동시에 만족시킬 수 있습니다.

<br/>

---

### 변수 - var(ES5), let, const(ES6)

- var의 단점

  - 변수 중복 선언이 가능하다. -> 변수값이 의도치않게 변경될 수 있다.  
    (let, const는 변수 중복 선언 시 에러 발생)

- let, const

  - let은 변수, 재할당 가능
  - const는 재할당 불가

- **const는 상수를 표현하는 키워드가 아니다!!**

  - const는 재할당이 불가능한 변하지 않는 수일 뿐.
  - const로 할당된 값도 변할 수 있다.

    ```js
    const num = [10];
    num.push(10);
    console.log(num);
    ```

- let은 const보다 메모리 성능이 더 나쁘나, 앱을 만들때는 이를 전혀 고려할 필요가 없는 수준이다.

<br/>

#### var, let, const 각각의 변수에 대해 설명해주세요.

JavaScript에는 변수를 선언하는 방법으로 var, let, const 세 가지 키워드가 있습니다. 이들은 각각 스코프(유효 범위), 호이스팅(끌어올림), 재할당 가능 여부 등에서 차이가 나기 때문에, 언제 어떤 키워드를 써야 할지 알고 있으면 코드 품질이 훨씬 높아집니다.

먼저 var는 ES5 이전부터 있던 가장 전통적인 변수 선언 방식입니다. 함수(function) 레벨 스코프를 가지며, 블록({ … }) 안에서 선언해도 그 블록을 무시하고 함수 전체나 전역(함수 밖이면 전역)에 변수가 생성됩니다. 그리고 선언 자체가 코드의 맨 위로 끌어올려지는데, 이때 초기화는 되지 않아 undefined 상태로 남았다가 실제 할당문에 도달했을 때 값이 부여됩니다. 이런 특성 때문에 의도치 않은 변수 충돌이나 예기치 않은 undefined 참조가 발생하기 쉽습니다.

ES2015에 도입된 let은 이러한 단점을 보완하기 위해 만든 블록 레벨 스코프 변수입니다. 중괄호로 감싼 영역 안에서만 유효하기 때문에, 반복문이나 조건문 안에서 선언한 변수가 외부로 새어나오지 않습니다. 또한 호이스팅은 일어나지만, 선언부 이전에 접근하려 하면 “Temporal Dead Zone”이라는 구간에 묶여 ReferenceError가 발생합니다. 즉, 선언 전에 변수를 읽거나 쓰면 에러가 나서 잘못된 참조를 예방해 줍니다. 그리고 가장 중요한 점은 재할당이 가능하다는 것입니다. count = 5; count = 10;처럼 필요에 따라 값을 바꿔야 할 때 사용합니다.

반면 const는 let과 완전히 같은 블록 레벨 스코프를 가지면서, 가장 눈에 띄는 차이점은 재할당이 금지된다는 점입니다. 한 번 선언과 초기화가 끝나면 그 식별자에 다른 값을 대입할 수 없기 때문에, “값을 바꾸면 안 되는 변수”라는 의미로 많이 소개되지만, 실제로는 바인딩(binding)만 고정됩니다. 따라서 객체나 배열을 가리키는 const 변수라도 내부 프로퍼티를 변경하거나 새 요소를 추가할 수 있습니다. const 선언부 이전에는 let과 마찬가지로 TDZ가 적용되어 선언 전 접근이 불가능합니다.

이렇게 세 가지 키워드는 용도와 의도가 분명히 다릅니다. 값을 여러 번 바꿔야 한다면 let, 한 번 정하고 바꾸지 않을 바인딩이라면 const, **구형 환경이나 함수 레벨 스코프가 정말 필요할 때만(또는 호환성을 위해) var**를 사용하는 것이 권장됩니다.

<br/>

#### 변수와 관련된 개념

- 키워드: var, let, const 같이 이미 언어에서 의미가 있는 단어를 말한다.

- 식별자: 키워드의 역할에 따라 다른 이름으로 불릴 수 있다. 키워드를 식별할 수 있는 문자 (function() sum {} 에서 sum이 식별자)

- 연산자, 피연산자, 표현식, 값

- 선언과 할당 - var, let 키워드만 가능

- TMI: 주석 단축키: Ctrl(Cmd) + /

- 변수를 선언만 하는 대표적인 경우: API 호출을 할 때 (변수를 선언한 후, 호출 결과값을 변수에 저장)

<br/>

---

### 자료형 (Data Type)

- 숫자형 - 말 그대로 숫자를 의미함. (10, 20, 0, -10, -20, 0.1, -0.1, 10e 등)

- 문자열형(문자열) - 값이 큰따옴표나, 작은따옴표, 백틱으로 둘러 쌓여진 것을 의미함

- 논리형 - true(참), false(거짓)

- 심볼형(ES6) - 유니크한 값, 어떤 의미를 가지고 있는 유니크한 값인지를

- undefined (특수 자료형) - 초기화 없이 변수를 선언언할 때 할당되는 값

- null (특수 자료형) - 의도적으로 비워둔 값, 추가적인 작업에 의해서 데이터가 결정이 되면 그 때 할당할 의도를 가지고 사용

- bigint - 9007199254740991보다 큰 수를 처리할 때 필요 (`BigInt(10n);`)

- [참조 자료형] 배열, 함수, 객체

- 배열: 대괄호로 둘러쌓인 값

- 객체: 중괄호로 둘어쌓인 값

- 함수: function 키워드르 선언된 값

<br/>
